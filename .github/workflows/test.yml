name: Test

on:
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - '**'

jobs:
  # Run Go unit tests across all packages
  unit-tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          cache: true
          cache-dependency-path: src/go.sum

      - name: Download dependencies
        working-directory: src
        run: go mod download

      - name: Run unit tests with coverage
        working-directory: src
        run: |
          echo "ğŸ§ª Running unit tests across all packages..."

          # Run tests with coverage and verbose output
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./... 2>&1 | tee test-output.txt

          # Check exit code
          TEST_EXIT_CODE=${PIPESTATUS[0]}

          # Generate coverage report
          echo ""
          echo "ğŸ“Š Coverage Report:"
          go tool cover -func=coverage.out | tail -20

          # Extract total coverage
          TOTAL_COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
          echo ""
          echo "ğŸ“ˆ Total Coverage: $TOTAL_COVERAGE"

          exit $TEST_EXIT_CODE

      - name: Generate coverage HTML report
        if: always()
        working-directory: src
        run: |
          if [ -f coverage.out ]; then
            go tool cover -html=coverage.out -o coverage.html
            echo "âœ… Coverage HTML report generated"
          fi

      - name: Upload coverage report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            src/coverage.out
            src/coverage.html
          retention-days: 7

      - name: Upload test output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-output
          path: src/test-output.txt
          retention-days: 7

      - name: Generate test summary
        if: always()
        working-directory: src
        run: |
          echo "## ğŸ§ª Unit Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Count test results
          if [ -f test-output.txt ]; then
            PASSED=$(grep -c "^--- PASS" test-output.txt || echo "0")
            FAILED=$(grep -c "^--- FAIL" test-output.txt || echo "0")
            SKIPPED=$(grep -c "^--- SKIP" test-output.txt || echo "0")

            echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| âŒ Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
            echo "| â­ï¸ Skipped | $SKIPPED |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Add coverage info
          if [ -f coverage.out ]; then
            TOTAL_COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
            echo "### ğŸ“Š Code Coverage: $TOTAL_COVERAGE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Coverage by package</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            go tool cover -func=coverage.out >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi

          # List failed tests if any
          if [ -f test-output.txt ] && grep -q "^--- FAIL" test-output.txt; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### âŒ Failed Tests" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep "^--- FAIL" test-output.txt >> $GITHUB_STEP_SUMMARY || true
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

  build-test:
    runs-on: ubuntu-latest
    needs: unit-tests

    strategy:
      matrix:
        include:
          - image_name: kimia
            dockerfile: Dockerfile.buildkit
            description: "Kimia (BuildKit)"
          - image_name: kimia-bud
            dockerfile: Dockerfile.buildah
            description: "Kimia-Bud (Buildah)"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build ${{ matrix.description }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ matrix.dockerfile }}
          push: false
          load: true
          tags: ${{ matrix.image_name }}:test
          cache-from: type=gha,scope=${{ matrix.image_name }}-test
          cache-to: type=gha,mode=max,scope=${{ matrix.image_name }}-test

      - name: Test ${{ matrix.description }}
        run: |
          echo "ğŸ§ª Running smoke tests for ${{ matrix.image_name }}..."
          
          # Test --version flag
          echo "Testing --version..."
          docker run --rm ${{ matrix.image_name }}:test --version || echo "âš ï¸  --version not available"
          
          # Test --help flag
          echo "Testing --help..."
          docker run --rm ${{ matrix.image_name }}:test --help || echo "âš ï¸  --help not available"
          
          echo "âœ… Basic tests passed for ${{ matrix.image_name }}"

      - name: Inspect ${{ matrix.description }}
        run: |
          echo "ğŸ“¦ Image details for ${{ matrix.image_name }}:"
          
          SIZE=$(docker image inspect ${{ matrix.image_name }}:test --format '{{.Size}}')
          SIZE_MB=$(echo "scale=2; $SIZE/1024/1024" | bc)
          echo "  Size: ${SIZE_MB} MB"
          
          ARCH=$(docker image inspect ${{ matrix.image_name }}:test --format '{{.Architecture}}')
          echo "  Architecture: ${ARCH}"
          
          OS=$(docker image inspect ${{ matrix.image_name }}:test --format '{{.Os}}')
          echo "  OS: ${OS}"
          
          CREATED=$(docker image inspect ${{ matrix.image_name }}:test --format '{{.Created}}')
          echo "  Created: ${CREATED}"

      - name: Test build with arguments
        run: |
          echo "ğŸ§ª Testing build with custom arguments..."
          docker run --rm \
            --cap-drop ALL \
            --cap-add SETUID \
            --cap-add SETGID \
            --security-opt seccomp=unconfined \
            --security-opt apparmor=unconfined \
            ${{ matrix.image_name }}:test \
            --context=/workspace --no-push 2>&1 | head -20 || echo "âš ï¸  Build test requires full setup"

  # Test both images in Kubernetes
  kubernetes-test:
    runs-on: ubuntu-latest
    needs: build-test
    if: github.event_name == 'pull_request'
    
    strategy:
      matrix:
        include:
          - image_name: kimia
            dockerfile: Dockerfile.buildkit
          - image_name: kimia-bud
            dockerfile: Dockerfile.buildah
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create k8s cluster with kind
        uses: helm/kind-action@v1.8.0
        with:
          cluster_name: kimia-test
          wait: 60s

      - name: Build and load ${{ matrix.image_name }} to kind
        run: |
          echo "ğŸ—ï¸  Building ${{ matrix.image_name }}..."
          docker build -f ${{ matrix.dockerfile }} -t ${{ matrix.image_name }}:test .
          
          echo "ğŸ“¦ Loading ${{ matrix.image_name }} into kind cluster..."
          kind load docker-image ${{ matrix.image_name }}:test --name kimia-test
          
          echo "âœ… Image loaded successfully"

      - name: Run Kubernetes tests for ${{ matrix.image_name }}
        run: |
          echo "ğŸ§ª Running Kubernetes tests for ${{ matrix.image_name }}..."
          
          # Create test namespace
          kubectl create namespace ${{ matrix.image_name }}-test
          
          # Create basic test job
          kubectl apply -f - <<EOF
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${{ matrix.image_name }}-version-test
            namespace: ${{ matrix.image_name }}-test
          spec:
            template:
              spec:
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 1000
                  fsGroup: 1000
                containers:
                - name: ${{ matrix.image_name }}
                  image: ${{ matrix.image_name }}:test
                  imagePullPolicy: Never
                  command: ["sh", "-c", "${{ matrix.image_name }} --version || echo 'Version test complete'"]
                  securityContext:
                    allowPrivilegeEscalation: true
                    capabilities:
                      drop: [ALL]
                      add: [SETUID, SETGID]
                restartPolicy: Never
            backoffLimit: 1
          EOF
          
          # Wait for job completion
          echo "â³ Waiting for job to complete..."
          kubectl wait --for=condition=complete job/${{ matrix.image_name }}-version-test \
            -n ${{ matrix.image_name }}-test --timeout=90s || \
            kubectl wait --for=condition=failed job/${{ matrix.image_name }}-version-test \
            -n ${{ matrix.image_name }}-test --timeout=10s
          
          # Check logs
          echo "ğŸ“‹ Job logs:"
          kubectl logs job/${{ matrix.image_name }}-version-test -n ${{ matrix.image_name }}-test || echo "No logs available"
          
          # Check job status
          JOB_STATUS=$(kubectl get job/${{ matrix.image_name }}-version-test -n ${{ matrix.image_name }}-test -o jsonpath='{.status.succeeded}')
          if [[ "$JOB_STATUS" == "1" ]]; then
            echo "âœ… Kubernetes test passed for ${{ matrix.image_name }}!"
          else
            echo "âŒ Kubernetes test failed for ${{ matrix.image_name }}"
            kubectl describe job/${{ matrix.image_name }}-version-test -n ${{ matrix.image_name }}-test
            exit 1
          fi

      - name: Test with sample build job
        run: |
          echo "ğŸ§ª Testing sample build scenario for ${{ matrix.image_name }}..."
          
          kubectl apply -f - <<EOF
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${{ matrix.image_name }}-build-test
            namespace: ${{ matrix.image_name }}-test
          spec:
            template:
              spec:
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 1000
                  fsGroup: 1000
                containers:
                - name: ${{ matrix.image_name }}
                  image: ${{ matrix.image_name }}:test
                  imagePullPolicy: Never
                  args:
                    - --help
                  securityContext:
                    allowPrivilegeEscalation: true
                    capabilities:
                      drop: [ALL]
                      add: [SETUID, SETGID]
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "100m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                restartPolicy: Never
            backoffLimit: 1
          EOF
          
          echo "â³ Waiting for build test job..."
          kubectl wait --for=condition=complete job/${{ matrix.image_name }}-build-test \
            -n ${{ matrix.image_name }}-test --timeout=60s || \
            kubectl wait --for=condition=failed job/${{ matrix.image_name }}-build-test \
            -n ${{ matrix.image_name }}-test --timeout=10s
          
          echo "ğŸ“‹ Build test logs:"
          kubectl logs job/${{ matrix.image_name }}-build-test -n ${{ matrix.image_name }}-test || echo "No logs available"
          
          echo "âœ… Build test complete for ${{ matrix.image_name }}"

      - name: Cleanup
        if: always()
        run: |
          echo "ğŸ§¹ Cleaning up..."
          kubectl delete namespace ${{ matrix.image_name }}-test --ignore-not-found=true
          echo "âœ… Cleanup complete"

  # Integration test summary
  test-summary:
    runs-on: ubuntu-latest
    needs: [unit-tests, build-test, kubernetes-test]
    if: always()

    steps:
      - name: Check test results
        run: |
          UNIT_STATUS="${{ needs.unit-tests.result }}"
          BUILD_STATUS="${{ needs.build-test.result }}"
          K8S_STATUS="${{ needs.kubernetes-test.result }}"

          echo "## ğŸ§ª Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test Suite | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|--------|" >> $GITHUB_STEP_SUMMARY

          if [[ "$UNIT_STATUS" == "success" ]]; then
            echo "| Unit Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          elif [[ "$UNIT_STATUS" == "skipped" ]]; then
            echo "| Unit Tests | â­ï¸ Skipped |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Unit Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "$BUILD_STATUS" == "success" ]]; then
            echo "| Build Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          elif [[ "$BUILD_STATUS" == "skipped" ]]; then
            echo "| Build Tests | â­ï¸ Skipped |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Build Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "$K8S_STATUS" == "success" ]]; then
            echo "| Kubernetes Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          elif [[ "$K8S_STATUS" == "skipped" ]]; then
            echo "| Kubernetes Tests | â­ï¸ Skipped (not a PR) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Kubernetes Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Images Tested" >> $GITHUB_STEP_SUMMARY
          echo "- **kimia** (BuildKit-based)" >> $GITHUB_STEP_SUMMARY
          echo "- **kimia-bud** (Buildah-based)" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Packages" >> $GITHUB_STEP_SUMMARY
          echo "- \`cmd/kimia\` - CLI argument parsing, version, help" >> $GITHUB_STEP_SUMMARY
          echo "- \`internal/auth\` - Registry authentication" >> $GITHUB_STEP_SUMMARY
          echo "- \`internal/build\` - Build execution, Git handling" >> $GITHUB_STEP_SUMMARY
          echo "- \`internal/preflight\` - Environment validation" >> $GITHUB_STEP_SUMMARY

          # Fail if unit tests or build tests failed
          if [[ "$UNIT_STATUS" != "success" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âŒ **Unit tests failed - please fix before merging**" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          if [[ "$BUILD_STATUS" != "success" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âŒ **Build tests failed - please fix before merging**" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
