package main

import (
	"fmt"

	"github.com/rapidfort/kimia/internal/build"
)

func printHelp() {
	if build.DetectBuilder() == "buildah" {
		fmt.Println("Kimia - Kubernetes-Native OCI Image Builder (Buildah)")
	} else {
		fmt.Println("Kimia - Kubernetes-Native OCI Image Builder (Buildkit)")
	}
	fmt.Println("Daemonless. Rootless. Privilege-free. Fully OCI-compliant.")
	fmt.Println()
	fmt.Println("USAGE:")
	fmt.Println("  kimia --context=<path|url> --destination=<image:tag> [options]")
	fmt.Println("  kimia check-environment               # Validate build environment")
	fmt.Println("  kimia --help                          # Show this help")
	fmt.Println("  kimia --version                       # Show version info")
	fmt.Println()
	fmt.Println("CORE OPTIONS:")
	fmt.Println("  -c, --context PATH                    Build context directory or Git URL")
	fmt.Println("  --context-sub-path PATH               Sub-directory within build context")
	fmt.Println("  -f, --dockerfile PATH                 Path to Dockerfile (default: Dockerfile)")
	fmt.Println("  -d, --destination IMAGE               Destination image with tag (repeatable)")
	fmt.Println("  -t, --target STAGE                    Target stage in multi-stage Dockerfile")
	fmt.Println()
	fmt.Println("BUILD OPTIONS:")
	fmt.Println("  --build-arg KEY=VALUE                 Build-time variables (repeatable)")
	fmt.Println("  --label KEY=VALUE                     Image metadata labels (repeatable)")
	fmt.Println("  --no-push                             Build only, skip push")
	fmt.Println("  --cache                               Enable layer caching")
	fmt.Println("  --cache-dir PATH                      Cache directory path")
	if build.DetectBuilder() == "buildkit" {
		fmt.Println("  --export-cache SPEC                   Export build cache (BuildKit only, repeatable)")
		fmt.Println("                                        Examples:")
		fmt.Println("                                          type=registry,ref=registry.io/cache:latest,mode=max")
		fmt.Println("                                          type=inline")
		fmt.Println("                                          type=local,dest=/tmp/cache")
		fmt.Println("  --import-cache SPEC                   Import build cache (BuildKit only, repeatable)")
		fmt.Println("                                        Examples:")
		fmt.Println("                                          type=registry,ref=registry.io/cache:latest")
		fmt.Println("                                          type=local,src=/tmp/cache")
	}
	fmt.Println("  --custom-platform PLATFORM            Target platform (e.g., linux/amd64)")
	if build.DetectBuilder() == "buildah" {
		fmt.Println("  --storage-driver DRIVER               Storage driver: vfs or overlay (default: vfs)")
	} else {
		fmt.Println("  --storage-driver DRIVER               Storage driver: native or overlay (default: native)")
	}
	fmt.Println()
	fmt.Println("REPRODUCIBLE BUILDS:")
	fmt.Println("  --reproducible                        Enable reproducible builds")
	fmt.Println("                                        - Uses timestamp 0 by default")
	fmt.Println("                                        - Uses SOURCE_DATE_EPOCH env var if set")
	fmt.Println("                                        - Disables caching, sorts args/labels")
	fmt.Println("                                        - Rewrites all file timestamps")
	fmt.Println("  --timestamp EPOCH                     Custom timestamp (Unix epoch seconds)")
	fmt.Println("                                        - Auto-enables reproducible builds")
	fmt.Println("                                        - Overrides SOURCE_DATE_EPOCH env var")
	fmt.Println("                                        Example: --timestamp=$(date +%s)")
	fmt.Println("                                                 --timestamp=1609459200")
	fmt.Println("                                                 --timestamp=$(git log -1 --format=%ct)")
	fmt.Println()
	if build.DetectBuilder() == "buildkit" {
		fmt.Println("ATTESTATION & SIGNING:")
		fmt.Println("Simple Mode (Level 1):")
		fmt.Println("  --attestation MODE                    Generate attestations")
		fmt.Println("                                        - off:  No attestations (default)")
		fmt.Println("                                        - min:  Provenance only, minimal info")
		fmt.Println("                                        - max:  SBOM + Provenance, full info")
		fmt.Println()
		fmt.Println("Advanced Mode (Level 2):")
		fmt.Println("  --attest type=TYPE,param=value        Docker-style attestation config (repeatable)")
		fmt.Println("                                        Types: sbom, provenance")
		fmt.Println()
		fmt.Println("  SBOM Parameters:")
		fmt.Println("    generator=IMAGE                     Custom SBOM scanner image")
		fmt.Println("    scan-context=true                   Include build context")
		fmt.Println("    scan-stage=true                     Include all build stages")
		fmt.Println()
		fmt.Println("  Provenance Parameters:")
		fmt.Println("    mode=min|max                        Detail level (default: max)")
		fmt.Println("    builder-id=ID                       Custom SLSA Builder ID")
		fmt.Println("    reproducible=true                   Mark as reproducible")
		fmt.Println("    version=v0.2|v1                     SLSA version (default: v0.2)")
		fmt.Println("    inline-only=true                    Only inline exporters")
		fmt.Println("    filename=NAME                       Output filename")
		fmt.Println()
		fmt.Println("Pass-Through (Level 3):")
		fmt.Println("  --buildkit-opt KEY=VALUE              Direct BuildKit option (repeatable)")
		fmt.Println()
		fmt.Println("Signing:")
		fmt.Println("  --sign                                Sign images with cosign after build")
		fmt.Println("  --cosign-key PATH                     Path to cosign private key")
		fmt.Println("  --cosign-password-env VAR             Environment variable containing password")
		fmt.Println()
		fmt.Println("Examples:")
		fmt.Println("  # Simple: Provenance only")
		fmt.Println("  kimia --attestation=min ...")
		fmt.Println()
		fmt.Println("  # Simple: Full attestations")
		fmt.Println("  kimia --attestation=max ...")
		fmt.Println()
		fmt.Println("  # Advanced: Custom SBOM scanner")
		fmt.Println("  kimia --attest type=sbom,generator=custom-scanner:v1 ...")
		fmt.Println()
		fmt.Println("  # Advanced: Provenance with builder ID")
		fmt.Println("  kimia --attest type=provenance,mode=max,builder-id=https://github.com/org/repo ...")
		fmt.Println()
		fmt.Println("  # Advanced: Both SBOM and Provenance")
		fmt.Println("  kimia --attest type=sbom,scan-context=true \\")
		fmt.Println("        --attest type=provenance,mode=max ...")
		fmt.Println()
		fmt.Println("Note: Cannot mix --attestation with --attest (--attest takes precedence)")
		fmt.Println()
	}
	fmt.Println("GIT OPTIONS:")
	fmt.Println("  --git-branch BRANCH                   Git branch to checkout")
	fmt.Println("  --git-revision SHA                    Git commit SHA to checkout")
	fmt.Println("  --git-token-file PATH                 File containing Git token")
	fmt.Println("  --git-token-user USER                 Git auth username (default: oauth2)")
	fmt.Println()
	fmt.Println("REGISTRY OPTIONS:")
	fmt.Println("  --insecure                            Allow insecure connections")
	fmt.Println("  --insecure-registry REGISTRY          Specific insecure registry (repeatable)")
	fmt.Println("  --push-retry N                        Push retry attempts (default: 1)")
	fmt.Println("  --image-download-retry N              Image pull retry attempts during build")
	fmt.Println("  --registry-certificate PATH           Registry certificate directory")
	fmt.Println()
	fmt.Println("AUTHENTICATION:")
	fmt.Println("  Kimia uses standard Docker config.json for registry authentication.")
	fmt.Println("  Default location: /home/kimia/.docker/config.json")
	fmt.Println()
	fmt.Println("  Supported authentication methods:")
	fmt.Println("    • Username/Password (base64 encoded)")
	fmt.Println("    • Credential helpers (ecr-login, gcr, acr-env)")
	fmt.Println("    • Cloud provider IAM (AWS, GCP, Azure)")
	fmt.Println()
	fmt.Println("  Configuration:")
	fmt.Println("    1. Login with docker:     docker login registry.io")
	fmt.Println("    2. Mount in Kubernetes:   See AUTHENTICATION EXAMPLES below")
	fmt.Println("    3. Custom location:       Set DOCKER_CONFIG env var")
	fmt.Println()
	fmt.Println("OUTPUT OPTIONS:")
	fmt.Println("  --tar-path PATH                       Export image to tar archive")
	fmt.Println("  --digest-file PATH                    Save image digest to file")
	fmt.Println("  --image-name-with-digest-file PATH    Save image name with digest")
	fmt.Println()
	fmt.Println("LOGGING:")
	fmt.Println("  -v, --verbosity LEVEL                 Log level: debug|info|warn|error")
	fmt.Println("  --log-timestamp                       Add timestamps to log output")
	fmt.Println()
	fmt.Println("OTHER:")
	fmt.Println("  --version                             Show version information")
	fmt.Println("  -h, --help                            Show this help message")
	fmt.Println()
	fmt.Println("STORAGE DRIVERS:")
	if build.DetectBuilder() == "buildah" {
		fmt.Println("  vfs       - Virtual File System (default, most compatible)")
		fmt.Println("              Works everywhere, no special requirements")
		fmt.Println("              Best for: TAR exports, maximum compatibility")
	} else {
		fmt.Println("  native    - Native snapshotter (default, most compatible)")
		fmt.Println("              Works everywhere, no special requirements")
		fmt.Println("              Best for: TAR exports, maximum compatibility")
	}
	fmt.Println()
	fmt.Println("  overlay   - Overlay filesystem (faster)")
	fmt.Println("              Best for: Performance, production builds")
	fmt.Println("              Note: TAR export may have issues in rootless mode")
	fmt.Println()
	fmt.Println("EXAMPLES:")
	fmt.Println()
	fmt.Println("  # Build from local directory")
	fmt.Println("  kimia --context=. --destination=registry.io/myapp:latest")
	fmt.Println()
	fmt.Println("  # Build with overlay driver (faster)")
	fmt.Println("  kimia --context=. --destination=registry.io/myapp:latest \\")
	fmt.Println("         --storage-driver=overlay")
	fmt.Println()
	fmt.Println("  # Build from Git repository")
	fmt.Println("  kimia --context=https://github.com/org/repo.git \\")
	fmt.Println("         --git-branch=main \\")
	fmt.Println("         --destination=registry.io/myapp:v1.0.0")
	fmt.Println()
	fmt.Println("  # Build from sub-directory in Git repository")
	fmt.Println("  kimia --context=https://github.com/org/repo.git \\")
	fmt.Println("         --context-sub-path=docker/app \\")
	fmt.Println("         --dockerfile=Dockerfile \\")
	fmt.Println("         --destination=registry.io/myapp:latest")
	fmt.Println()
	fmt.Println("  # Build with custom arguments and labels")
	fmt.Println("  kimia --context=. \\")
	fmt.Println("         --destination=registry.io/myapp:latest \\")
	fmt.Println("         --build-arg VERSION=1.0.0 \\")
	fmt.Println("         --label maintainer=team@company.com \\")
	fmt.Println("         --cache")
	fmt.Println()
	fmt.Println("  # Build for specific platform")
	fmt.Println("  kimia --context=. \\")
	fmt.Println("         --destination=registry.io/myapp:latest \\")
	fmt.Println("         --custom-platform=linux/arm64")
	fmt.Println()
	fmt.Println("  # Export to TAR (use vfs/native for reliability)")
	fmt.Println("  kimia --context=. \\")
	fmt.Println("         --destination=myapp:latest \\")
	fmt.Println("         --tar-path=/output/myapp.tar \\")
	fmt.Println("         --storage-driver=vfs \\")
	fmt.Println("         --no-push")
	fmt.Println()
	fmt.Println("  # Reproducible build (uses epoch 0)")
	fmt.Println("  kimia --context=. \\")
	fmt.Println("         --destination=registry.io/myapp:v1 \\")
	fmt.Println("         --reproducible")
	fmt.Println()
	fmt.Println("  # Reproducible build with custom timestamp")
	fmt.Println("  kimia --context=. \\")
	fmt.Println("         --destination=registry.io/myapp:v1 \\")
	fmt.Println("         --timestamp=1609459200")
	fmt.Println()
	fmt.Println("  # CI/CD: Reproducible build with git commit timestamp")
	fmt.Println("  export SOURCE_DATE_EPOCH=$(git log -1 --format=%ct)")
	fmt.Println("  kimia --context=. \\")
	fmt.Println("         --destination=registry.io/myapp:v1 \\")
	fmt.Println("         --reproducible")
	fmt.Println()
	if build.DetectBuilder() == "buildkit" {
		fmt.Println("  # Build with registry cache (export + import)")
		fmt.Println("  kimia --context=. \\")
		fmt.Println("         --destination=registry.io/myapp:v1 \\")
		fmt.Println("         --cache \\")
		fmt.Println("         --import-cache type=registry,ref=registry.io/cache/myapp:latest \\")
		fmt.Println("         --export-cache type=registry,ref=registry.io/cache/myapp:latest,mode=max")
		fmt.Println()
		fmt.Println("  # Build with inline cache (embedded in the pushed image)")
		fmt.Println("  kimia --context=. \\")
		fmt.Println("         --destination=registry.io/myapp:v1 \\")
		fmt.Println("         --cache \\")
		fmt.Println("         --export-cache type=inline")
		fmt.Println()
		fmt.Println("  # Build with local cache (useful in CI with a mounted cache volume)")
		fmt.Println("  kimia --context=. \\")
		fmt.Println("         --destination=registry.io/myapp:v1 \\")
		fmt.Println("         --cache \\")
		fmt.Println("         --import-cache type=local,src=/mnt/cache \\")
		fmt.Println("         --export-cache type=local,dest=/mnt/cache,mode=max")
		fmt.Println()
		fmt.Println("  # Build with SBOM attestation")
		fmt.Println("  kimia --context=. \\")
		fmt.Println("         --destination=registry.io/myapp:v1 \\")
		fmt.Println("         --attestation=max")
		fmt.Println()
		fmt.Println("  # Build with attestation and signing")
		fmt.Println("  export COSIGN_PASSWORD=my-secret-password")
		fmt.Println("  kimia --context=. \\")
		fmt.Println("         --destination=registry.io/myapp:v1 \\")
		fmt.Println("         --attestation=max \\")
		fmt.Println("         --sign \\")
		fmt.Println("         --cosign-key=cosign.key \\")
		fmt.Println("         --cosign-password-env=COSIGN_PASSWORD")
		fmt.Println()
	}
	fmt.Println("AUTHENTICATION EXAMPLES:")
	fmt.Println()
	fmt.Println("  # Docker Hub - Login locally")
	fmt.Println("  docker login")
	fmt.Println("  kimia --context=. --destination=username/myapp:latest")
	fmt.Println()
	fmt.Println("  # Private registry - Login with credentials")
	fmt.Println("  docker login registry.example.com")
	fmt.Println("  kimia --context=. --destination=registry.example.com/myapp:latest")
	fmt.Println()
	fmt.Println("  # Kubernetes - Mount Docker config as secret")
	fmt.Println("  kubectl create secret generic docker-config \\")
	fmt.Println("    --from-file=config.json=$HOME/.docker/config.json")
	fmt.Println()
	fmt.Println("  # In Pod spec:")
	fmt.Println("  volumeMounts:")
	fmt.Println("  - name: docker-config")
	fmt.Println("    mountPath: /home/kimia/.docker")
	fmt.Println("    readOnly: true")
	fmt.Println("  volumes:")
	fmt.Println("  - name: docker-config")
	fmt.Println("    secret:")
	fmt.Println("      secretName: docker-config")
	fmt.Println()
	fmt.Println("  # AWS ECR - Using credential helper")
	fmt.Println("  # config.json:")
	fmt.Println("  {")
	fmt.Println("    \"credHelpers\": {")
	fmt.Println("      \"123456.dkr.ecr.us-east-1.amazonaws.com\": \"ecr-login\"")
	fmt.Println("    }")
	fmt.Println("  }")
	fmt.Println()
	fmt.Println("  # Google GCR - Using credential helper")
	fmt.Println("  # config.json:")
	fmt.Println("  {")
	fmt.Println("    \"credHelpers\": {")
	fmt.Println("      \"gcr.io\": \"gcr\"")
	fmt.Println("    }")
	fmt.Println("  }")
	fmt.Println()
	fmt.Println("  # Custom location - Set DOCKER_CONFIG")
	fmt.Println("  export DOCKER_CONFIG=/custom/path/.docker")
	fmt.Println("  kimia --context=. --destination=registry.io/myapp:latest")
	fmt.Println()
	fmt.Println("  # Environment variables (creates config.json automatically)")
	fmt.Println("  export DOCKER_USERNAME=myuser")
	fmt.Println("  export DOCKER_PASSWORD=mypassword")
	fmt.Println("  # DOCKER_REGISTRY is optional - auto-detected from --destination")
	fmt.Println("  kimia --context=. --destination=registry.example.com/myapp:latest")
	fmt.Println()
	fmt.Println("ENVIRONMENT VARIABLES:")
	fmt.Println("  SOURCE_DATE_EPOCH   - Timestamp for reproducible builds (Unix epoch)")
	fmt.Println("  STORAGE_DRIVER      - Override storage driver (vfs/native or overlay)")
	fmt.Println("  BUILDAH_FORMAT      - Image format (oci or docker)")
	fmt.Println("")
	fmt.Println("  Authentication (in order of precedence):")
	fmt.Println("  DOCKER_CONFIG       - Docker config directory (default: /home/kimia/.docker)")
	fmt.Println("  DOCKER_USERNAME     - Username for registry (creates config.json if missing)")
	fmt.Println("  DOCKER_PASSWORD     - Password for registry (creates config.json if missing)")
	fmt.Println("  DOCKER_REGISTRY     - Registry URL (optional, auto-detected from --destination)")
	fmt.Println("")
	fmt.Println("  Note: If DOCKER_USERNAME/PASSWORD are set but no config.json exists,")
	fmt.Println("        Kimia automatically creates config.json with auth for the destination registry.")
	fmt.Println()
	printVersionInfo()
	fmt.Println()
	fmt.Println("For more information: https://github.com/rapidfort/kimia")
}

func printVersionInfo() {
	fmt.Printf("Version: %s | Built: %s | Commit: %s\n",
		Version,
		convertEpochStringToHumanReadable(BuildDate),
		CommitSHA)
}